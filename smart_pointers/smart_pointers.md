# Smart Pointers

- the "traditional" pointer was inherited from C
- a built-in type
- a pointer variable stores a binary number which represents and address in memory
- can represent the address of a stack variable
- can be used to manage memory on the heap
- drawbacks of traditional pointer:
    - no concept of ownership
        - any code that uses a pointer can reassign it
    - no destructor
    - rarely needed in C++11
- smart pointer are classes which encapsulate allocated memory
    - implemented using RAII
    - smart pointers has ownership of the allocated memory 
    - allocated memory can only be accessed through public member functions
- `auto_ptr`: first smart pointe
    - transferred allocated memory when copied
    - unpredicatable behavior when auto_ptrs were stored in containers
- `unique_ptr`: a fixed version of auto pointer
    - cannot be copied or ssigned to
    - memory can be transferred to another object tho
        - use of std::move()
- `shared_ptr`: shares the allocated memory with other shared_ptrs
    - reference counting is used to manage the memory
        - memory is released when no more objects are pointing to it
    - similar to garbage collecting languages
    - more overhead than uniqu_ptr